import tkinter as tk
from tkinter import messagebox
import subprocess
import pickle
import os

# Constants for storing window position
POSITION_FILE = "window_position.pkl"

# Function to save window position
def save_window_position(window):
    try:
        with open(POSITION_FILE, "wb") as f:
            f.write(pickle.dumps(window.geometry()))
    except Exception as e:
        print(f"Error saving window position: {e}")

# Function to load window position
def load_window_position(window):
    if os.path.exists(POSITION_FILE):
        try:
            with open(POSITION_FILE, "rb") as f:
                geometry = pickle.loads(f.read())
                window.geometry(geometry)
        except Exception as e:
            print(f"Error loading window position: {e}")

def create_checklist_window(title, checklist_title, checklist_items, external_program):
    def update_continue_button():
        if all(var.get() for var in checklist_vars):
            continue_button["state"] = "normal"
        else:
            continue_button["state"] = "disabled"

    def on_continue():
        save_window_position(root)
        root.destroy()
        try:
            subprocess.run(external_program, check=True)
        except Exception as e:
            messagebox.showerror("Error", f"Failed to run the program: {e}")

    root = tk.Tk()
    root.title(title)

    load_window_position(root)

    # Create the main frame
    frame = tk.Frame(root, padx=20, pady=20)
    frame.pack(expand=True, fill="both")

    # Checklist title
    title_label = tk.Label(frame, text=checklist_title, font=("Arial", 16))
    title_label.pack(pady=(0, 10))

    # Checklist items
    checklist_vars = []
    for item in checklist_items:
        var = tk.BooleanVar()
        # Replace "\n" with actual newline characters
        item_text = item.replace("\\n", "\n")
        checkbox = tk.Checkbutton(frame, text=item_text, variable=var, command=update_continue_button, wraplength=400, anchor="w", justify="left")
        checkbox.pack(fill="x", padx=10, pady=5)
        checklist_vars.append(var)

    # Continue and Cancel buttons
    button_frame = tk.Frame(frame)
    button_frame.pack(pady=(20, 0))

    continue_button = tk.Button(
        button_frame, text="Continue", state="disabled", command=on_continue, font=("Arial", 12)
    )
    continue_button.pack(side="left", padx=(0, 10))

    cancel_button = tk.Button(
        button_frame, text="Cancel", command=lambda: (save_window_position(root), root.destroy()), font=("Arial", 12)
    )
    cancel_button.pack(side="left")

    # Resize window to fit content
    root.update_idletasks()
    root.minsize(root.winfo_reqwidth(), root.winfo_reqheight())

    # Run the main event loop
    root.protocol("WM_DELETE_WINDOW", lambda: (save_window_position(root), root.destroy()))
    root.mainloop()

# Check for admin rights
def is_admin():
    try:
        return ctypes.windll.shell32.IsUserAnAdmin()
    except:
        return False

if __name__ == "__main__":
    if not is_admin():
        ctypes.windll.shell32.ShellExecuteW(
            None, "runas", sys.executable, " ".join(sys.argv), None, 1
        )
        sys.exit()

    window_title = "Checklist Application"
    checklist_window_title = "Please Complete the Checklist"
    
    # Manually defined checklist items with newlines for longer text
    items = [
        "Check the power supply",
        "Ensure the network cable is connected",
        "Verify software installation\nand configuration",
        "Update antivirus definitions",
        "Run system diagnostics\nfor hardware issues",
        "Review error logs\nfor recent issues",
        "Test application functionality",
        "Backup critical files",
        "Notify the team of changes",
        "Confirm system reboot"
    ]
    
    external_program_path = "notepad.exe"  # Change to your program's path

    create_checklist_window(window_title, checklist_window_title, items, external_program_path)
